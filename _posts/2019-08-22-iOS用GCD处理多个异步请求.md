---
layout: post
title: iOS用GCD处理多个异步请求
date: 2019-06-21
tag: iOS
---

在实际开发中处理图片上传时，需要几个异步请求完成后再处理一些其他的操作,就可以使用GCD的一些相关的知识来解决问题。



### 第一种解决办是通过dispatch_queue_t的dispatch_group_enter和dispatch_group_leave来控制实现。

一、常用的几个方法

关于dispatch_group_enter常用的几个方法
dispatch_group_enter :通知 group,下个任务要放入 group 中执行了
dispatch_group_leave: 通知 group,任务成功完成,要移除,与 enter成对出现
dispatch_group_wait: 在任务组完成时调用，或者任务组超时是调用（完成指的是enter和leave次数一样多）
dispatch_group_notify: 只要任务全部完成了,就会在最后调用

二、实际项目里面的代码示例

1、代码示例

```
[self.selectImageArray removeAllObjects];
    dispatch_group_t group = dispatch_group_create();
    for (int i = 0;i < [self.photoDataArray count]; i++) {
        dispatch_group_enter(group);
        UIImage *image = [self.photoDataArray objectAtIndex:i];
        NSData *data = UIImageJPEGRepresentation(image, 0.00001);
        CMUploadPicModel *picModel = [[CMUploadPicModel alloc] init];
        picModel.data = data;
        [LJRequest RequestWithApiName:DEF_API_UPLOADFILE ReuqestType:RequestTypePOSTUploadFile Header:nil Params:@{@"picArray":@[picModel]} NeedUseToken:YES ResultClass:[CMBaseResponseModel class] ResponseBlock:^(BOOL isSuccess, id response) {
            CMBaseResponseModel * baseResponseModel = (CMBaseResponseModel*)response;
            [self.selectImageArray addObject:baseResponseModel.data];
            NSLog(@"%d",i);
            dispatch_group_leave(group);
        }];
    }
    dispatch_group_notify(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        NSLog(@"完成%ld",[self.selectImageArray count]);
        dispatch_async(dispatch_get_main_queue(), ^{
            // UI更新代码
            [self createCarCheckInfo];
        });


    });

```
2、代码执行顺序打印

```
2019-08-22 14:54:45.694615+0800 CarManagerApp[10041:2195606] =====第一张0图片上传完成
2019-08-22 14:54:45.697987+0800 CarManagerApp[10041:2195606] =====第一张1图片上传完成
2019-08-22 14:54:45.700562+0800 CarManagerApp[10041:2195606] =====第一张2图片上传完成
2019-08-22 14:54:45.702676+0800 CarManagerApp[10041:2195606] =====第一张3图片上传完成
2019-08-22 14:54:45.828199+0800 CarManagerApp[10041:2195606] =====第一张5图片上传完成
2019-08-22 14:54:45.833134+0800 CarManagerApp[10041:2195606] =====第一张4图片上传完成
2019-08-22 14:54:45.833329+0800 CarManagerApp[10041:2195783] =====上传任务结束6

```

三、启示

通过dispatch_group_enter和dispatch_group_leave来控制异步执行。执行全部请求后回到dispatch_group_notify做其他的处理操作。

### 第二种解决办法是通过dispatch_queue_t的dispatch_semaphore

一、定义：

1、信号量：就是一种可用来控制访问资源的数量的标识，设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。

其实，这有点类似锁机制了，只不过信号量都是系统帮助我们处理了，我们只需要在执行线程之前，设定一个信号量值，并且在使用时，加上信号量处理方法就行了。

一、常用的几个方法

//创建信号量，参数：信号量的初值，如果小于0则会返回NULL
dispatch_semaphore_create（信号量值）
 
//等待降低信号量
dispatch_semaphore_wait（信号量，等待时间）
 
//提高信号量
dispatch_semaphore_signal(信号量)

三、实际项目里面的代码示例

1、代码示例

```
dispatch_semaphore_t semaPhore = dispatch_semaphore_create(1);
    dispatch_queue_t quene = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    [self.selectImageArray removeAllObjects];
    for (int i = 0;i < [self.photoDataArray count]; i++) {
        dispatch_async(quene, ^{
            dispatch_semaphore_wait(semaPhore, DISPATCH_TIME_FOREVER);
            UIImage *image = [self.photoDataArray objectAtIndex:i];
            NSData *data = UIImageJPEGRepresentation(image, 0.00001);
            CMUploadPicModel *picModel = [[CMUploadPicModel alloc] init];
            picModel.data = data;
            [LJRequest RequestWithApiName:DEF_API_UPLOADFILE ReuqestType:RequestTypePOSTUploadFile Header:nil Params:@{@"picArray":@[picModel]} NeedUseToken:YES ResultClass:[CMBaseResponseModel class] ResponseBlock:^(BOOL isSuccess, id response) {
                CMBaseResponseModel * baseResponseModel = (CMBaseResponseModel*)response;
                [self.selectImageArray addObject:baseResponseModel.data];
                NSLog(@"=====第一张%d图片上传完成",i);
                dispatch_semaphore_signal(semaPhore);
            }];
        });
    }
    
     NSLog(@"=====上传任务结束");

```

2、代码执行顺序打印

```
2019-08-22 15:16:58.127179+0800 CarManagerApp[10053:2198132] =====上传任务结束
2019-08-22 15:16:58.452326+0800 CarManagerApp[10053:2198132] =====第一张0图片上传完成
2019-08-22 15:16:58.624179+0800 CarManagerApp[10053:2198132] =====第一张1图片上传完成
2019-08-22 15:16:58.786843+0800 CarManagerApp[10053:2198132] =====第一张2图片上传完成
2019-08-22 15:16:58.946099+0800 CarManagerApp[10053:2198132] =====第一张3图片上传完成
2019-08-22 15:16:59.110623+0800 CarManagerApp[10053:2198132] =====第一张4图片上传完成
2019-08-22 15:16:59.254174+0800 CarManagerApp[10053:2198132] =====第一张5图片上传完成

```
四、启示

从上面打印可以看出，通过设置线程的并发量。然后结合信号量的只是可以巧妙的实效异步请求同步执行。按照先后顺序来执行。


<br>
转载请注明：[iWolf的博客](https://iwolfsex.github.io/) » [iOS用GCD处理多个异步请求](http://iWolf.com/2019/06/iOS用GCD处理多个异步请求/)  
