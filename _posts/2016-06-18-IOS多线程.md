---
layout: post
title: IOS多线程
date: 2016-06-18
tag: iOS
---

### （一）PThread
PThread是一组C语言的多线程接口。跨平台，可移植性高。
                
### （二）NSThread
优点：NSThread 比其他两个轻量级
缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销.
 
 
### （三）NSOperation 、NSOperationQueue
NSOperation是个抽象类，使用它必须用它的子类，可以实现它或者使用它定义好的两个子类：NSInvocationOperation 和 NSBlockOperation。
 
优点：
>* 1、不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。
>* 2、设置线程执行的优先级。
>* 3、可以控制线程 的状态。比如（开始start）、（取消 clean）
>* 4、添加依赖关系。（但是要）
 
添加依赖关系要注意一下3点：
>* 1、不要建立循环依赖，会造成死锁，原因同循环引用
>* 2、使用依赖建议只使用NSInvocationOperation，NSInvocationOperation和NSBlockOperation混用会导致依赖关系无法正常实现。
>* 3、依赖关系不光在同队列中生效，不同队列的NSOperation对象之前设置的依赖关系一样会生效
 
### （四）GCD（全称：Grand Central Dispatch）
 
1、GCD简介 
Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。在iOS4.0开始之后才能使用。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。现在的iOS系统都升级到7了，所以不用担心该技术不能使用。
 
优点：
>* 1、GCD可用于多核的并行运算 
>* 2、GCD会自动利用更多的CPU内核（比如双核、四核） 
>* 3、GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程） 
>* 4、程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码 
 
2、 任务和队列
任务：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在GCD中是放在block中的。执行任务有两种方式：同步执行和异步执行。两者的主要区别是：是否具备开启新线程的能力
 
同步执行（sync）：只能在当前线程中执行任务，不具备开启新线程的能力
异步执行（async）：可以在新的线程中执行任务，具备开启新线程的能力
 
3、串行队列和并行队列。
 
并行队列（Concurrent Dispatch Queue）：可以让多个任务并行（同时）执行（自动开启多个线程同时执行任务）
并行功能只有在异步（dispatch_async）函数下才有效
串行队列（Serial Dispatch Queue）：让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）
 
4下表是几种不同组合方式
 
<img src="/images/posts/IOS多线程/IOS多线程.jpeg" > 

5、GCD的其他方法

* 1、dispatch_barrier_async

dispatch_barrier_async是在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行

* 2、dispatch_after （GCD的延时执行方法：当我们需要延迟执行一段代码时，就需要用到GCD的dispatch_after方法。）

```
 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ // 2秒后异步执行这里的代码... NSLog(@"run-----"); });
```

* 3、dispatch_once （GCD的一次性代码(只执行一次)） 

我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了GCD的dispatch_once方法。使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次

```
static dispatch_once_t onceToken;
dispatch_once(&onceToken, ^{
    // 只执行1次的代码(这里面默认是线程安全的)
});
```
 
* 4、dispatch_apply（GCD的快速迭代方法）

通常我们会用for循环遍历，但是GCD给我们提供了快速迭代的方法dispatch_apply，使我们可以同时遍历。

 ```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 
dispatch_apply(6, queue, ^(size_t index) { 

	NSLog(@"%zd------%@",index, [NSThread currentThread]);
	 
});
 ```

* 5、dispatch_group_async（GCD的队列组）

dispatch_group_async可以实现监听一组任务是否完成，完成后得到通知执行其他的操作。这个方法很有用，比如你执行三个下载任务，当三个任务都下载完成后你才通知界面说完成的了

 ```
dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 执行1个耗时的异步操作 }); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // 执行1个耗时的异步操作 }); dispatch_group_notify(group, dispatch_get_main_queue(), ^{ // 等前面的异步操作都执行完毕后，回到主线程... });
 ```
 
<br>
转载请注明：[iWolf的博客](http://iWolf.com) » [IOS多线程](http://iWolf.com/2016/06/IOS多线程/)  


