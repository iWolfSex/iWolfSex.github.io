---
layout: post
title: å±€ç½‘å†…ç‚¹å¯¹ç‚¹è¯­éŸ³å¯¹è®²äºŒ
date: 2018-03-08
tag: iOS
---

åœ¨[å±€ç½‘å†…ç‚¹å¯¹ç‚¹è¯­éŸ³å¯¹è®²ä¸€](http://iWolf.com/2018/03/å±€ç½‘å†…ç‚¹å¯¹ç‚¹è¯­éŸ³å¯¹è®²ä¸€/)ä¸­æˆ‘è®²è§£äº†åˆ©ç”¨socketæ¥å£çš„æ¥å£è°ƒTCPä¼ è¾“åè®®å®ç°äº†éŸ³é¢‘æ•°æ®åœ¨ç½‘ç»œä¸­çš„ä¼ è¾“ã€‚è¿™ä¸€è®²ä¸»è¦è®²è§£éŸ³é¢‘æ•°æ®çš„é‡‡é›†ã€å‹ç¼©å’Œè§£å‹ã€‚æˆ‘æŠŠéŸ³é¢‘çš„é‡‡é›†å’Œæ’­æ”¾å°è£…æˆäº†ä¸¤ä¸ªç±»ã€‚
éŸ³é¢‘çš„å½•å–æˆ‘ä»¬è¦ç”¨çš„åˆ°iOSæä¾›çš„AudioToolboxæ¡†æ¶ã€‚è¿™ä¸ªåº“æ˜¯Cçš„æ¥å£ï¼Œç”¨äºåœ¨çº¿æµåª’ä½“éŸ³é¢‘çš„æ’­æ”¾ã€‚è¿™é‡Œä¸»è¦è®²è§£Audio Queueå¯¹éŸ³é¢‘è¿›è¡Œæ’­æ”¾ã€‚åˆ©ç”¨Audio Queueå¯æ˜¯å®ç°ä¸€è¾¹é‡‡é›†éŸ³é¢‘æ•°æ®ä¸€è¾¹ä¼ è¾“éŸ³é¢‘æ•°æ®ã€‚ç±»ä¼¼äºæ‰“ç”µè¯å§ã€‚
ä»€ä¹ˆæ˜¯Audio Queueï¼Ÿæˆ‘åœ¨ç½‘ä¸Šæ‰¾äº†ä¸€ä¸ªæˆªå›¾ã€‚æ˜¯äººå®¶ä»Appleçš„å®˜æ–¹æ–‡æ¡£ä¸Šæˆªä¸‹ä»¥ä¸‹è¯¥å›¾ã€‚
Appleçš„å®˜æ–¹æ–‡æ¡£ä¸Šæˆªä¸‹ä»¥ä¸‹è¯¥å›¾

<img src="/images/posts/å±€ç½‘å†…ç‚¹å¯¹ç‚¹è¯­éŸ³å¯¹è®²äºŒ/å±€ç½‘å†…ç‚¹å¯¹ç‚¹è¯­éŸ³å¯¹è®²äºŒ.png" > 

ç†è§£AudioQueueçš„å·¥ä½œåŸç†ã€‚æˆ‘ä¹Ÿæ˜¯æ‘˜å½•å…¶ä»–äººçš„åŸè¯å¦‚ä¸‹ã€‚
1. ç”¨æˆ·è°ƒç”¨ç›¸åº”çš„æ–¹æ³•ï¼Œå°†éŸ³é¢‘æ•°æ®ä»ç¡¬ç›˜ä¸­è¯»å…¥åˆ°AudioQueueçš„ç¼“å†²åŒºä¸­ï¼Œå¹¶å°†ç¼“å†²åŒºé€å…¥éŸ³é¢‘é˜Ÿåˆ—ã€‚ 
2. ç”¨æˆ·Appé€šè¿‡AudioQueueæä¾›çš„æ¥å£ï¼Œå‘Šè¯‰å¤–æ”¾è®¾å¤‡ï¼Œç¼“å†²åŒºä¸­å·²ç»æœ‰æ•°æ®ï¼Œå¯ä»¥æ‹¿å»æ’­æ”¾ã€‚ 
3. å½“ä¸€ä¸ªç¼“å†²åŒºä¸­çš„éŸ³é¢‘æ•°æ®æ’­æ”¾å®Œæ¯•ä¹‹åï¼ŒAudioQueueå‘Šè¯‰ç”¨æˆ·ï¼Œå½“å‰æœ‰ä¸€ä¸ªç©ºçš„ç¼“å†²åŒºå¯ä»¥ç”¨æ¥ç»™ä½ å¡«å……æ•°æ®ã€‚ 
4. é‡å¤ä»¥ä¸Šæ­¥éª¤ï¼Œç›´è‡³æ•°æ®æ’­æ”¾å®Œæ¯•ã€‚

###  åˆ©ç”¨AudioToolboxå®ç°éŸ³é¢‘æµæ•°æ®çš„é‡‡é›†å’Œæ’­æ”¾çš„æºç 

é‡‡é›†ç±»çš„å°è£…

å¤´æ–‡ä»¶

```
//
//  RMCQRecord.h
//  RMCQAudioQueue
//
//  Created by åˆ˜è¶… on 14-4-2.
//  Copyright (c) 2014å¹´ åˆ˜è¶…. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <AudioToolbox/AudioToolbox.h>
#import <AudioToolbox/AudioFile.h>
#define kNumberBuffers 3

#define t_sample SInt16

#define kSamplingRate 20000
#define kNumberChannels 1
#define kBitsPerChannels (sizeof(t_sample) * 8)
#define kBytesPerFrame (kNumberChannels * sizeof(t_sample))
//#define kFrameSize (kSamplingRate * sizeof(t_sample))
#define kFrameSize 1000

typedef struct AQCallbackStruct
{
    AudioStreamBasicDescription mDataFormat;
    AudioQueueRef queue;
    AudioQueueBufferRef mBuffers[kNumberBuffers];
    AudioFileID outputFile;
    
    unsigned long frameSize;
    long long recPtr;
    int run;
} AQCallbackStruct;

@interface RMCQRecord : NSObject{
    AQCallbackStruct aqc;
    AudioFileTypeID fileFormat;
    long audioDataLength;
    Byte audioByte[999999];
    long audioDataIndex;
}
- (id) init;
- (void) start;
- (void) stop;
-(void) reset;
-(void) dispose;
- (void) pause;
-(void)close;
- (Byte*) getBytes;
- (void) processAudioBuffer:(AudioQueueBufferRef) buffer withQueue:(AudioQueueRef) queue;

@property (nonatomic, assign) AQCallbackStruct aqc;
@property (nonatomic, assign) long audioDataLength;
@end

```

æºæ–‡ä»¶

```
//
//  RMCQRecord.m
//  RMCQAudioQueue
//
//  Created by åˆ˜è¶… on 14-4-2.
//  Copyright (c) 2014å¹´ åˆ˜è¶…. All rights reserved.
//

#import "RMCQRecord.h"

@implementation RMCQRecord
@synthesize aqc;
@synthesize audioDataLength;


static void AQInputCallback (void * inUserData,
                             AudioQueueRef inAudioQueue,
                             AudioQueueBufferRef inBuffer,
                             const AudioTimeStamp * inStartTime,
                             unsigned long inNumPackets,
                             const AudioStreamPacketDescription * inPacketDesc)
{
    
    RMCQRecord * engine = (__bridge RMCQRecord *) inUserData;
    if (inNumPackets > 0)
    {
        [engine processAudioBuffer:inBuffer withQueue:inAudioQueue];
    }
    
    if (engine.aqc.run)
    {
        AudioQueueEnqueueBuffer(engine.aqc.queue, inBuffer, 0, NULL);
    }
}

- (id) init
{
    self = [super init];
    
    if (self)
    {
        
        aqc.mDataFormat.mSampleRate = kSamplingRate;
        aqc.mDataFormat.mFormatID = kAudioFormatLinearPCM;
        aqc.mDataFormat.mFormatFlags = kLinearPCMFormatFlagIsSignedInteger |kLinearPCMFormatFlagIsPacked;
        aqc.mDataFormat.mFramesPerPacket = 1;
        aqc.mDataFormat.mChannelsPerFrame = kNumberChannels;
        
        aqc.mDataFormat.mBitsPerChannel = kBitsPerChannels;
        
        aqc.mDataFormat.mBytesPerPacket = kBytesPerFrame;
        aqc.mDataFormat.mBytesPerFrame = kBytesPerFrame;
        
        aqc.frameSize = kFrameSize;
        
        AudioQueueNewInput(&aqc.mDataFormat, AQInputCallback, (__bridge void *)(self), NULL, kCFRunLoopCommonModes,0, &aqc.queue);
        
        for (int i=0;i<kNumberBuffers;i++)
        {
            AudioQueueAllocateBuffer(aqc.queue, aqc.frameSize, &aqc.mBuffers[i]);
            AudioQueueEnqueueBuffer(aqc.queue, aqc.mBuffers[i], 0, NULL);
        }
        aqc.recPtr = 0;
        aqc.run = 1;
    }
    audioDataIndex = 0;
    return self;
}

- (void) dealloc
{
    AudioQueueStop(aqc.queue, true);
    aqc.run = 0;
    AudioQueueDispose(aqc.queue, true);
}

- (void) start
{
    AudioQueueStart(aqc.queue, NULL);
}

- (void) stop
{
    AudioQueueStop(aqc.queue, true);
}

- (void) pause
{
    AudioQueuePause(aqc.queue);
}

-(void) reset{
    AudioQueueReset(aqc.queue);
}
-(void)dispose{
    AudioQueueDispose(aqc.queue,true);
}
-(void)close{
    AudioFileClose(aqc.outputFile);
}
- (Byte *)getBytes
{
    return audioByte;
}

- (void) processAudioBuffer:(AudioQueueBufferRef) buffer withQueue:(AudioQueueRef) queue
{
    NSLog(@"processAudioData :%ld", buffer->mAudioDataByteSize);
    //å¤„ç†dataï¼šå¿˜è®°ocæ€ä¹ˆcopyå†…å­˜äº†ï¼Œäºæ˜¯é‡‡ç”¨çš„C++ä»£ç ï¼Œè®°å¾—æŠŠç±»åç¼€æ”¹ä¸º.mmã€‚åŒPlay
    memcpy(audioByte+audioDataIndex, buffer->mAudioData, buffer->mAudioDataByteSize);
    audioDataIndex +=buffer->mAudioDataByteSize;
    audioDataLength = audioDataIndex;
}

@end

```
æ’­æ”¾ç±»çš„å°è£…

å¤´æ–‡ä»¶

```
//
//  RMCQPlay.h
//  RMCQAudioQueue
//
//  Created by åˆ˜è¶… on 14-4-2.
//  Copyright (c) 2014å¹´ åˆ˜è¶…. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <AudioToolbox/AudioToolbox.h>

// Audio Settings
#define kNumberBuffers      3
#define t_sample             SInt16
#define kSamplingRate       20000
#define kNumberChannels     1
#define kBitsPerChannels    (sizeof(t_sample) * 8)
#define kBytesPerFrame      (kNumberChannels * sizeof(t_sample))
//#define kFrameSize          (kSamplingRate * sizeof(t_sample))
#define kFrameSize          1000


#define QUEUE_BUFFER_SIZE  2//é˜Ÿåˆ—ç¼“å†²ä¸ªæ•°
#define EVERY_READ_LENGTH  10240 //æ¯æ¬¡ä»æ–‡ä»¶è¯»å–çš„é•¿åº¦
#define MIN_SIZE_PER_FRAME 10240 //æ¯ä¾¦æœ€å°æ•°æ®é•¿åº¦

@interface RMCQPlay : NSObject
{
    //éŸ³é¢‘å‚æ•°
    AudioStreamBasicDescription audioDescription;
    // éŸ³é¢‘æ’­æ”¾é˜Ÿåˆ—
    AudioQueueRef audioQueue;
    // éŸ³é¢‘ç¼“å­˜
    AudioQueueBufferRef audioQueueBuffers[QUEUE_BUFFER_SIZE];
}

-(void)Play:(Byte *)audioByte Length:(long)len;
-(void)Stop;

@end

```

æºæ–‡ä»¶

```
//
//  RMCQPlay.m
//  RMCQAudioQueue
//
//  Created by åˆ˜è¶… on 14-4-2.
//  Copyright (c) 2014å¹´ åˆ˜è¶…. All rights reserved.
//

#import "RMCQPlay.h"
@interface RMCQPlay()
{
    Byte *audioByte;
    long audioDataIndex;
    long audioDataLength;
}
@end
@implementation RMCQPlay

//å›è°ƒå‡½æ•°(Callback)çš„å®ç°
static void BufferCallback(void *inUserData,AudioQueueRef inAQ,AudioQueueBufferRef buffer){
    
    NSLog(@"processAudioData :%u", (unsigned int)buffer->mAudioDataByteSize);
    
    RMCQPlay* player=(__bridge RMCQPlay*)inUserData;
    
    [player FillBuffer:inAQ queueBuffer:buffer];
}

void soundCompleteCallBack(SystemSoundID soundID, void * clientDate) {
    NSLog(@"æ’­æ”¾å®Œæˆ");
    AudioServicesDisposeSystemSoundID(soundID);
}

//ç¼“å­˜æ•°æ®è¯»å–æ–¹æ³•çš„å®ç°
-(void)FillBuffer:(AudioQueueRef)queue queueBuffer:(AudioQueueBufferRef)buffer
{
    if(audioDataIndex + EVERY_READ_LENGTH < audioDataLength)
    {
        memcpy(buffer->mAudioData, audioByte+audioDataIndex, EVERY_READ_LENGTH);
        audioDataIndex += EVERY_READ_LENGTH;
        buffer->mAudioDataByteSize =EVERY_READ_LENGTH;
        AudioQueueEnqueueBuffer(queue, buffer, 0, NULL);
    }
    
}

-(void)SetAudioFormat
{
    ///è®¾ç½®éŸ³é¢‘å‚æ•°
    audioDescription.mSampleRate  = kSamplingRate;//é‡‡æ ·ç‡
    audioDescription.mFormatID    = kAudioFormatLinearPCM;
    audioDescription.mFormatFlags =  kAudioFormatFlagIsSignedInteger;//|kAudioFormatFlagIsNonInterleaved;
    audioDescription.mChannelsPerFrame = kNumberChannels;
    audioDescription.mFramesPerPacket  = 1;//æ¯ä¸€ä¸ªpacketä¸€ä¾¦æ•°æ®
    audioDescription.mBitsPerChannel   = kBitsPerChannels;//av_get_bytes_per_sample(AV_SAMPLE_FMT_S16)*8;//æ¯ä¸ªé‡‡æ ·ç‚¹16bité‡åŒ–
    audioDescription.mBytesPerFrame    = kBytesPerFrame;
    audioDescription.mBytesPerPacket   = kBytesPerFrame;
    
    [self CreateAudioQueue];
}

-(void)CreateAudioQueue
{
    [self Cleanup];
    //ä½¿ç”¨playerçš„å†…éƒ¨çº¿ç¨‹æ’­
    AudioQueueNewOutput(&audioDescription, BufferCallback, (__bridge void *)(self), nil, nil, 0, &audioQueue);
    if(audioQueue)
    {
        ////æ·»åŠ bufferåŒº
        for(int i=0;i<QUEUE_BUFFER_SIZE;i++)
        {
            int result =  AudioQueueAllocateBuffer(audioQueue, EVERY_READ_LENGTH, &audioQueueBuffers[i]);
            ///åˆ›å»ºbufferåŒºï¼ŒMIN_SIZE_PER_FRAMEä¸ºæ¯ä¸€ä¾¦æ‰€éœ€è¦çš„æœ€å°çš„å¤§å°ï¼Œè¯¥å¤§å°åº”è¯¥æ¯”æ¯æ¬¡å¾€bufferé‡Œå†™çš„æœ€å¤§çš„ä¸€æ¬¡è¿˜å¤§
            NSLog(@"AudioQueueAllocateBuffer i = %d,result = %d",i,result);
        }
    }
}

-(void)Cleanup
{
    if(audioQueue)
    {
        NSLog(@"Release AudioQueueNewOutput");
        
        [self Stop];
        for(int i=0; i < QUEUE_BUFFER_SIZE; i++)
        {
            AudioQueueFreeBuffer(audioQueue, audioQueueBuffers[i]);
            audioQueueBuffers[i] = nil;
        }
        audioQueue = nil;
    }
}

-(void)Stop
{
    NSLog(@"Audio Player Stop");
    
    AudioQueueFlush(audioQueue);
    AudioQueueReset(audioQueue);
    AudioQueueStop(audioQueue,TRUE);

}

-(void)Play:(Byte *)byte Length:(long)len
{
    [self Stop];
    audioByte = byte;
    audioDataLength = len;
    
    NSLog(@"Audio Play Start >>>>>");
    
    [self SetAudioFormat];
    
    AudioQueueReset(audioQueue);
    audioDataIndex = 0;
    for(int i=0; i<QUEUE_BUFFER_SIZE; i++)
    {
        [self FillBuffer:audioQueue queueBuffer:audioQueueBuffers[i]];
    }
    AudioQueueStart(audioQueue, NULL);
}
@end

```

###  PCMæ•°æ®è½¬AMRã€‚å³éŸ³é¢‘æ•°æ®çš„ç¼–ç äºè§£ç ã€‚

PCM:åœ¨æˆ‘çœ‹æ¥å°±æ˜¯åŸå§‹çš„éŸ³é¢‘æ•°æ®ã€‚æœªç»è¿‡å‹ç¼©å¤„ç†ã€‚
AMRï¼Œå…¨ç§°æ˜¯ï¼šAdaptive Multi-Rateï¼Œè‡ªé€‚åº”å¤šé€Ÿç‡ï¼Œæ˜¯ä¸€ç§éŸ³é¢‘ç¼–ç æ–‡ä»¶æ ¼å¼ï¼Œä¸“ç”¨äºæœ‰æ•ˆåœ°å‹ç¼©è¯­éŸ³é¢‘ç‡ã€‚
AMRéŸ³é¢‘ä¸»è¦ç”¨äºç§»åŠ¨è®¾å¤‡çš„éŸ³é¢‘å‹ç¼©ï¼Œå‹ç¼©æ¯”éå¸¸é«˜ï¼Œä½†æ˜¯éŸ³è´¨æ¯”è¾ƒå·®ï¼Œä¸»è¦ç”¨äºè¯­éŸ³ç±»çš„éŸ³é¢‘å‹ç¼©ï¼Œä¸é€‚åˆå¯¹éŸ³è´¨è¦æ±‚è¾ƒé«˜çš„éŸ³ä¹ç±»éŸ³é¢‘çš„å‹ç¼©

è¿™éƒ¨åˆ†ä»£ç æ˜¯åœ¨ç½‘ä¸Šæ‰¾çš„ã€‚æˆ‘è´´å‡ºæ¥ä¾›å‚è€ƒã€‚

å¤´æ–‡ä»¶


```
//
//  RecordAmrCode.h
//  VoiceChat
//
//  Created by MacOS on 14-9-15.
//  Copyright (c) 2014å¹´ MacOS. All rights reserved.
//

/**
 *  ä½¿ç”¨audioquequeæ¥å®æ—¶å½•éŸ³ï¼Œè¾¹å½•éŸ³è¾¹è½¬ç ï¼Œå¯ä»¥è®¾ç½®è‡ªå·±çš„è½¬ç æ–¹å¼ã€‚ä»PCMæ•°æ®è½¬
 */

#import <Foundation/Foundation.h>
@interface RecordAmrCode : NSObject

//å°†PCMæ ¼å¼Dataè¿›è¡Œç¼–ç ï¼Œè½¬æ¢ä¸ºAMRæ ¼å¼
- (NSData *)encodePCMDataToAMRData:(NSData *)pcmData;

//è®²AMRæ ¼å¼Dataè§£ç ï¼Œè½¬æ¢ä¸ºPCMæ ¼å¼
- (NSData *)decodeAMRDataToPCMData:(NSData *)amrData;

typedef struct _RTP_header
{
    /* byte 0 */
#if (BYTE_ORDER == LITTLE_ENDIAN)
    unsigned char csrc_len:4;   /* expect 0 */
    unsigned char extension:1;  /* expect 1, see RTP_OP below */
    unsigned char padding:1;    /* expect 0 */
    unsigned char version:2;    /* expect 2 */
#elif (BYTE_ORDER == BIG_ENDIAN)
    unsigned char version:2;    /* ç‰ˆæœ¬å· */
    unsigned char padding:1;    /* å¡«å…… */
    unsigned char extension:1;  /* å¡«å……å¤´ */
    unsigned char csrc_len:4;   /* ä½œç”¨æºä¸ªæ•° */
#else
#error Neither big nor little
#endif
    /* byte 1 */
#if (BYTE_ORDER == LITTLE_ENDIAN)
    unsigned char payload:7;    /*  */
    unsigned char marker:1;     /*except 1  */
#elif (BYTE_ORDER == BIG_ENDIAN)
    unsigned char marker:1;     /* å¸§è¾¹ç•Œæ ‡è¯† */
    unsigned char payload:7;    /* è´Ÿè½½ç±»å‹ */
#endif
    /* bytes 2, 3 */
    unsigned short seq_no;      /* åºåˆ—å·*/
    /* bytes 4-7 */
    unsigned int timestamp;     /* æ—¶é—´ */
    /* bytes 8-11 */
    unsigned int ssrc;          /* stream number is used here. */
} RTP_header;

@end


```

æºæ–‡ä»¶


```
//
//  RecordAmrCode.m
//  VoiceChat
//
//  Created by MacOS on 14-9-15.
//  Copyright (c) 2014å¹´ MacOS. All rights reserved.
//

#import "RecordAmrCode.h"

#define PCM_FRAME_SIZE 160 // 8khz 8000*0.02=160
#define MAX_AMR_FRAME_SIZE 32
#define AMR_FRAME_COUNT_PER_SECOND 50

#define AMR_MAGIC_NUMBER "#!AMR\n"

//amrç¼–ç ã€è§£ç 
#import "interf_enc.h"
#include "interf_dec.h"

@implementation RecordAmrCode

- (NSData *)encodePCMDataToAMRData:(NSData *)pcmData
{
    void *destate = 0;
    RTP_header rtpHead;
    memset(&rtpHead,0,sizeof(RTP_header));
    rtpHead.marker = 1;
    rtpHead.payload = 0;
    int nLen = 0;
    int nSLen = 0;
    
    // amr å‹ç¼©å¥æŸ„
    destate = Encoder_Interface_init(0);
    if (destate == 0) {
        return nil;
    }
    
    NSMutableData *amrData = [NSMutableData data];
    
    //ç¼–ç 
    const void *recordingData = pcmData.bytes;
    NSUInteger pcmLen = pcmData.length;
    
    if (pcmLen<=0){
        return nil;
    }
    if (pcmLen%2!=0){
        pcmLen--; //é˜²æ­¢æ„å¤–ï¼Œå¦‚æœä¸æ˜¯å¶æ•°ï¼Œæƒ…æ„¿å‡å»æœ€åä¸€ä¸ªå­—èŠ‚ã€‚
        NSLog(@"ä¸æ˜¯å¶æ•°");
    }
    
    unsigned char buffer[320];
    for (int i =0; i < pcmLen ;i+=160*2) {
        short *pPacket = (short *)((unsigned char*)recordingData+i);
//        if (pcmLen-i<160*2){
//            continue; //ä¸æ˜¯ä¸€ä¸ªå®Œæ•´çš„å°±æ‹œæ‹œ
//        }
        
        memset(buffer, 0, sizeof(buffer));
        //encode
        int recvLen = Encoder_Interface_Encode(destate,MR475,pPacket,buffer,0);
       
        //tcpä¼ è¾“æ–¹å¼æ‰€ä»¥åŠ tcpå¤´
//        nLen = recvLen + sizeof(RTP_header);
        nLen = recvLen;
        unsigned char amrBuf[336];
        memset(amrBuf, 0, sizeof(amrBuf));
        amrBuf[0] = '$';
        amrBuf[1] = 2;
        amrBuf[2] = nLen>>8;
        amrBuf[3] = nLen&0xff;
        memcpy(amrBuf+4,&rtpHead,sizeof(RTP_header));
        memcpy(amrBuf+4+sizeof(RTP_header),buffer,recvLen);
        
        nSLen = sizeof(RTP_header) + 4 + recvLen;

        if (recvLen>0) {
            NSData *data = [NSData dataWithBytes:amrBuf length:nSLen];
            [amrData appendData:data];
        }
    }

    return amrData;
}

- (NSData *)decodeAMRDataToPCMData:(NSData *)amrData
{
    void *destate;
    int nFrameCount = 0;
    int stdFrameSize;
    int nTemp;
    char bErr = 0;
    unsigned char stdFrameHeader;
    
    unsigned char amrFrame[MAX_AMR_FRAME_SIZE];
    short pcmFrame[PCM_FRAME_SIZE];
    
    if (amrData.length <= 0) {
        return nil;
    }
    
    const char* rfile = [amrData bytes];
    int maxLen = [amrData length];
    int pos = 0;
   
    NSMutableData* pcmData = [[NSMutableData alloc]init];
    
    /* init decoder */
    destate = Decoder_Interface_init();
    
    // è¯»ç¬¬ä¸€å¸§ - ä½œä¸ºå‚è€ƒå¸§
    memset(amrFrame, 0, sizeof(amrFrame));
    memset(pcmFrame, 0, sizeof(pcmFrame));
    
    //å‚æ•°ä¸€æ¬¡æ˜¯æ¥æ”¶åˆ°çš„amræ•°æ®,ä¸‹æ¬¡å¼€å§‹ç‚¹,ä¸€ä¸ªamrFrame,å¸§å¤§å° å¸§å¤´
    nTemp = ReadAMRFrameFirstData(rfile,pos,maxLen, amrFrame, &stdFrameSize, &stdFrameHeader);
    if (nTemp==0) {
        Decoder_Interface_exit(destate);
        return nil;
    }
    pos += nTemp;
    // è§£ç ä¸€ä¸ªAMRéŸ³é¢‘å¸§æˆPCMæ•°æ®
    Decoder_Interface_Decode(destate, amrFrame, pcmFrame, 0);
    nFrameCount++;
    //fwrite(pcmFrame, sizeof(short), PCM_FRAME_SIZE, fpwave);
    [pcmData appendBytes:pcmFrame length:PCM_FRAME_SIZE*sizeof(short)];
    
    // é€å¸§è§£ç AMRå¹¶å†™åˆ°pcmDataé‡Œ
    while(1)
    {
        memset(amrFrame, 0, sizeof(amrFrame));
        memset(pcmFrame, 0, sizeof(pcmFrame));
        //if (!ReadAMRFrame(fpamr, amrFrame, stdFrameSize, stdFrameHeader)) break;
        
        nTemp = ReadAMRFrameData(rfile,pos,maxLen, amrFrame, stdFrameSize, stdFrameHeader);
        if (!nTemp) {bErr = 1;break;}
        pos += nTemp;
        
        // è§£ç ä¸€ä¸ªAMRéŸ³é¢‘å¸§æˆPCMæ•°æ® (8k-16b-å•å£°é“)
        Decoder_Interface_Decode(destate, amrFrame, pcmFrame, 0);
        nFrameCount++;
        //fwrite(pcmFrame, sizeof(short), PCM_FRAME_SIZE, fpwave);
        [pcmData appendBytes:pcmFrame length:PCM_FRAME_SIZE*sizeof(short)];
    }
//  NSLog(@"frame = %d", nFrameCount);
    Decoder_Interface_exit(destate);
    
    return pcmData;
}

// è¯»ç¬¬ä¸€ä¸ªå¸§ - (å‚è€ƒå¸§)
// è¿”å›å€¼: 0-å‡ºé”™; 1-æ­£ç¡®
int ReadAMRFrameFirstData(char* fpamr,int pos,int maxLen, unsigned char frameBuffer[], int* stdFrameSize, unsigned char* stdFrameHeader)
{
    int nPos = 0;
    memset(frameBuffer, 0, sizeof(frameBuffer));//ä¸€å¸§amræ•°æ®
    //å»æ‰rtpåŒ…çš„16ä¸ªå­—èŠ‚
    if(fpamr[0] == '$'){
        nPos = 16;
    }
    else{
        return 0;//ä¸æ˜¯rtpåŒ…
    }
    // å…ˆè¯»å¸§å¤´
    stdFrameHeader[0] = fpamr[nPos];
    nPos++;
    
    if (pos+nPos >= maxLen) {
        return 0;
    }
    
    // æ ¹æ®å¸§å¤´è®¡ç®—å¸§å¤§å°
    *stdFrameSize = caclAMRFrameSize(*stdFrameHeader);
    
    // è¯»é¦–å¸§
    frameBuffer[0] = *stdFrameHeader;
    if ((*stdFrameSize-1)*sizeof(unsigned char)<=0) {
        return 0;
    }
    
    memcpy(&(frameBuffer[1]), fpamr+pos+nPos, (*stdFrameSize-1)*sizeof(unsigned char));
    //fread(&(frameBuffer[1]), 1, (*stdFrameSize-1)*sizeof(unsigned char), fpamr);
    //if (feof(fpamr)) return 0;
    nPos += (*stdFrameSize-1)*sizeof(unsigned char);
    if (pos+nPos >= maxLen) {
        return 0;
    }
    
    return nPos;
}

int ReadAMRFrameData(char* fpamr,int pos,int maxLen, unsigned char frameBuffer[], int stdFrameSize, unsigned char stdFrameHeader)
{
    int nPos = 0;
    unsigned char frameHeader; // å¸§å¤´
    
    memset(frameBuffer, 0, sizeof(frameBuffer));
    
    // è¯»å¸§å¤´
    // å¦‚æœæ˜¯åå¸§(ä¸æ˜¯æ ‡å‡†å¸§å¤´)ï¼Œåˆ™ç»§ç»­è¯»ä¸‹ä¸€ä¸ªå­—èŠ‚ï¼Œç›´åˆ°è¯»åˆ°æ ‡å‡†å¸§å¤´
    while(1)
    {
        //å»æ‰rtpåŒ…çš„16ä¸ªå­—èŠ‚
        if(fpamr[0] == '$'){
            nPos = 16;
        }
        else{
            return 0;//ä¸æ˜¯rtpåŒ…
        }

        if (pos+nPos >=maxLen) {
            return 0;
        }
        frameHeader = fpamr[pos+nPos]; pos++;
        if (frameHeader == stdFrameHeader) break;
    }
    
    // è¯»è¯¥å¸§çš„è¯­éŸ³æ•°æ®(å¸§å¤´å·²ç»è¯»è¿‡)
    frameBuffer[0] = frameHeader;
    //bytes = fread(&(frameBuffer[1]), 1, (stdFrameSize-1)*sizeof(unsigned char), fpamr);
    //if (feof(fpamr)) return 0;
    if ((stdFrameSize-1)*sizeof(unsigned char)<=0) {
        return 0;
    }
    memcpy(&(frameBuffer[1]), fpamr+pos+nPos, (stdFrameSize-1)*sizeof(unsigned char));
    nPos += (stdFrameSize-1)*sizeof(unsigned char);
    if (pos+nPos >= maxLen) {
        return 0;
    }
    
    return nPos;
}


// æ ¹æ®å¸§å¤´è®¡ç®—å½“å‰å¸§å¤§å°
int caclAMRFrameSize(unsigned char frameHeader)
{
    int mode;
    int temp1 = 0;
    int temp2 = 0;
    int frameSize;
    int amrEncodeMode[] = {4750, 5150, 5900, 6700, 7400, 7950, 10200, 12200}; // amr ç¼–ç æ–¹å¼
    
    temp1 = frameHeader;
    
    // ç¼–ç æ–¹å¼ç¼–å· = å¸§å¤´çš„3-6ä½
    temp1 &= 0x78; // 0111-1000
    temp1 >>= 3;
    
    mode = amrEncodeMode[temp1];
    
    // è®¡ç®—amréŸ³é¢‘æ•°æ®å¸§å¤§å°
    // åŸç†: amr ä¸€å¸§å¯¹åº”20msï¼Œé‚£ä¹ˆä¸€ç§’æœ‰50å¸§çš„éŸ³é¢‘æ•°æ®
    temp2 = myround((double)(((double)mode / (double)AMR_FRAME_COUNT_PER_SECOND) / (double)8));
    
    frameSize = myround((double)temp2 + 0.5);
    return frameSize;
}

//decode

const int myround(const double x)
{
    return((int)(x+0.5));
}


@end



```

[æ•´ä¸ªé¡¹ç›®çš„ä»£ç åœ¨GitHubä¸Šçš„](https://github.com/iWolf/RMCQAudioQueue.git)ã€‚å¯è‡ªè¡Œä¸‹è½½è¿è¡Œã€‚




<br>
è½¬è½½è¯·æ³¨æ˜ï¼š[iWolfçš„åšå®¢](http://iWolf.com) Â» [å±€ç½‘å†…ç‚¹å¯¹ç‚¹è¯­éŸ³å¯¹è®²äºŒ](http://iWolf.com/2018/03/å±€ç½‘å†…ç‚¹å¯¹ç‚¹è¯­éŸ³å¯¹è®²äºŒ/)  


ğŸˆ³ï¸